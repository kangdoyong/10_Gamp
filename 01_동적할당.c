#include <stdio.h>
#include <stdlib.h>

// 동적할당이란?
// 런타임 중에 메모리 공간을 할당시키는 것을 의미
// c언어에서는 malloc()과 calloc() 함수를 통해 메모리를 할당시킬 수 있음
// realloc() 함수를 메모리 재할당이 가능
// 메모리 해제도 직접해야 함, free() 함수
// 해제된 메모리를 가리키는 댕글링 포인터가 되지 않도록
// 포인터 변수 NULL 값을 할당시키는 것이 좋습니다.

// 댕글링 포인터란?
// 해제된 메모리 영역을 가리키는 포인터 변수를 의미
// 유효하지 않은 영역을 가리키는 포인터 변수이므로
// 사용 시, 예측하지 못한 결과를 얻게 됨


void main()
{
	// 동적할당 시, 메모리 영역 중 힙 영역에 할당됨

	// int형 메모리를 동적할당하여
	// 포인터 변수 p가 동적할당된 메모리의 주소를 가리키도록 합니다.
	int* p = (int*)malloc(sizeof(int));
	// void* malloc(size) : size 바이트 크기의 메모리를 할당하고
	// 할당한 메모리의 시작 주소를 반환합니다.
	// 내가 사용하고자 하는 형식으로 캐스팅 하면 됨

	// 동적할당시킨 메모리 영역에 10이라 값을 할당
	// -> 동적할당된 메모리도 처음에 쓰레기값이 저장되어 있으므로
	//    할당 후, 초기화하여 사용하는 것이 좋습니다.
	*p = 10;

	printf("포인터 변수 p의 주소 : %p \n", &p);
	printf("동적할당된 메모리의 주소 : %p \n", p);
	printf("동적할당된 메모리에 할당된 값 : %d \n", *p);

	// 동적할당시킨 메모리를 해제
	// free 함수에 파라미터로 동적할당된 메모리의 시작주소를 넘깁니다.
	free(p);
	// 일반적으로 게임 같은 프로그램 등은 계속해서 반복적인 구조에서
	// 특정 로직을 실행시키는 구조임
	// 이러한 반복적인 구조에서 동적할당을 사용하고, 해제하지 않는다면
	// 이후 해당 동적할당 코드가 다시 호출된다고 가정했을 때,
	// 추가적인 할당으로 인해 메모리의 크기가 계속해서 늘어남 
	// -> 결과, 메모리 누수로 이어짐 (프로그램 프리징이나 다운의 위험)

	// 해제한 후에 포인터 변수가 들고 있는 값(해제된 메모리의 시작 주소)
	printf("p의 값 : %p \n", p);

	// 댕글링 포인터가 되지 않도록, 해제 후 포인터 변수의 값을 NULL로 초기화
	p = NULL;
}